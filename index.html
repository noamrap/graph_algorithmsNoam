<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×××œ×›×ª ×”××œ×’×•×¨×™×ª××™× - × ×•×¢× ×¨×¤×•×¤×•×¨×˜</title>
    <style>
        /* --- ××©×ª× ×™× ×•×¢×™×¦×•×‘ ×‘×¡×™×¡×™ --- */
        :root {
            --bg-core: #050b14;
            --bg-panel: #0f172a;
            --border: #1e293b;
            --primary: #00f3ff;       /* Cyan Neon */
            --gold: #ffd700;          /* Gold */
            --accent: #ff0055;        /* Neon Red */
            --success: #00ff9d;       /* Matrix Green */
            --text-main: #e2e8f0;
            --text-dim: #64748b;
            --font-ui: 'Segoe UI', system-ui, sans-serif;
            --font-mono: 'Consolas', 'Monaco', monospace;
        }

        * { box-sizing: border-box; outline: none; user-select: none; }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-core);
            color: var(--text-main);
            font-family: var(--font-ui);
            height: 100vh;
            overflow: hidden;
        }

        /* --- ××¡×š ×¤×ª×™×—×” (SPLASH SCREEN) --- */
        #splash-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
            z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-in-out, transform 0.8s ease-in-out;
        }

        .royal-card {
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid var(--gold);
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.2);
            animation: float 4s ease-in-out infinite;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        /* ××¤×§×˜ × ×•×¦×¥ */
        .royal-card::before {
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 215, 0, 0.1), transparent);
            transform: rotate(45deg); animation: shine 3s infinite; pointer-events: none;
        }

        .crown { font-size: 4rem; display: block; margin-bottom: 10px; animation: spin-crown 6s infinite linear; }
        
        .royal-title { color: var(--gold); font-size: 1.2rem; letter-spacing: 3px; text-transform: uppercase; font-weight: bold; margin-bottom: 10px; }
        
        .royal-name {
            font-size: 3rem; font-weight: 900; margin: 0;
            background: linear-gradient(to right, #00f3ff, #fff, var(--gold));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 243, 255, 0.3);
        }

        .funny-subtitle { color: #aaa; font-style: italic; margin-top: 10px; font-size: 1rem; min-height: 1.5em;}

        .start-btn-large {
            margin-top: 40px;
            padding: 15px 50px;
            font-size: 1.5rem;
            background: var(--primary);
            color: #000;
            border: none;
            border-radius: 50px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 20px var(--primary);
            transition: all 0.3s;
        }
        .start-btn-large:hover { transform: scale(1.1); box-shadow: 0 0 40px var(--primary); background: #fff; }

        /* --- ×”×××©×§ ×”×¨××©×™ (APP INTERFACE) --- */
        #app-interface {
            display: none; /* ××•×¡×ª×¨ ×‘×”×ª×—×œ×” */
            height: 100vh;
            grid-template-rows: 70px 1fr;
            opacity: 0;
            transition: opacity 1s;
        }

        /* HEADER */
        header {
            background: rgba(15, 23, 42, 0.95);
            border-bottom: 1px solid var(--primary);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 30px;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.1);
        }

        .app-logo { font-size: 1.2rem; font-weight: bold; color: var(--text-main); }
        .app-logo span { color: var(--primary); }

        .nav-pills { display: flex; gap: 10px; }
        .nav-btn {
            background: transparent; border: 1px solid var(--border); color: var(--text-dim);
            padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: 0.2s;
        }
        .nav-btn:hover { color: #fff; border-color: var(--primary); }
        .nav-btn.active { background: rgba(0, 243, 255, 0.15); color: var(--primary); border-color: var(--primary); }

        /* LAYOUT */
        .main-grid { display: grid; grid-template-columns: 1fr 400px; height: 100%; overflow: hidden; }

        /* STAGE (GRAPH) */
        .stage {
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            position: relative;
            overflow: hidden;
        }
        svg { width: 100%; height: 100%; cursor: grab; }

        /* GRAPH ELEMENTS */
        .edge { stroke: #334155; stroke-width: 2; transition: 0.3s; }
        .edge.active { stroke: var(--gold); stroke-width: 4; filter: drop-shadow(0 0 5px var(--gold)); }
        .edge.visited { stroke: var(--primary); opacity: 0.5; }
        
        .label-bg { fill: var(--bg-core); stroke: var(--border); rx: 4; }
        .label-text { fill: var(--text-main); font-size: 12px; font-family: var(--font-mono); font-weight: bold; text-anchor: middle; dominant-baseline: central; }

        .node-circle { fill: var(--bg-panel); stroke: var(--text-dim); stroke-width: 3px; r: 30; transition: 0.3s; }
        .node-text { fill: white; font-size: 18px; font-weight: bold; font-family: var(--font-mono); text-anchor: middle; dominant-baseline: central; }
        .node-badge { font-size: 11px; fill: var(--gold); font-weight: bold; text-anchor: middle; opacity: 0; transition: 0.3s; font-family: var(--font-mono); }

        .group.active .node-circle { stroke: var(--gold); fill: #3f2e04; transform: scale(1.15); }
        .group.visited .node-circle { stroke: var(--primary); fill: rgba(0, 243, 255, 0.1); }
        .group.finished .node-circle { stroke: var(--success); fill: rgba(0, 255, 157, 0.1); }

        /* SCC Colors */
        .group[data-scc="0"] .node-circle { stroke: #ff0055; }
        .group[data-scc="1"] .node-circle { stroke: #ffe600; }
        .group[data-scc="2"] .node-circle { stroke: #00ff9d; }

        /* SIDEBAR */
        .sidebar {
            background: var(--bg-panel); border-right: 1px solid var(--border);
            display: flex; flex-direction: column; box-shadow: -5px 0 20px rgba(0,0,0,0.5); z-index: 10;
        }

        .panel { padding: 15px; border-bottom: 1px solid var(--border); background: rgba(0,0,0,0.2); }
        .panel h3 { margin: 0 0 10px 0; color: var(--primary); font-size: 0.85rem; text-transform: uppercase; letter-spacing: 1px; display: flex; justify-content: space-between; }

        /* DATA STRUCTURES */
        .ds-items { display: flex; gap: 8px; overflow-x: auto; height: 45px; align-items: center; padding-bottom: 5px; }
        .ds-item {
            min-width: 40px; height: 40px; background: var(--bg-core); border: 1px solid var(--border); border-radius: 6px;
            display: flex; align-items: center; justify-content: center; font-family: var(--font-mono); font-weight: bold;
            font-size: 0.9rem; animation: popIn 0.3s;
        }
        .ds-item.active { border-color: var(--gold); color: var(--gold); transform: translateY(-3px); box-shadow: 0 0 10px rgba(255, 215, 0, 0.2); }

        /* LOGS */
        .log-container {
            flex: 1; overflow-y: auto; padding: 15px; background: #080c14;
            font-family: var(--font-mono); font-size: 0.9rem; line-height: 1.5;
        }
        .log-entry { margin-bottom: 8px; padding: 8px 10px; border-radius: 4px; background: rgba(255,255,255,0.03); border-right: 3px solid transparent; animation: slideIn 0.2s; }
        .l-info { border-color: var(--text-dim); color: var(--text-dim); }
        .l-act { border-color: var(--primary); color: #befafe; background: rgba(0, 243, 255, 0.05); }
        .l-calc { border-color: var(--gold); color: #fef08a; }
        .l-success { border-color: var(--success); color: #bef264; }
        .l-err { border-color: var(--accent); color: #fca5a5; }

        /* CONTROLS */
        .controls { padding: 20px; background: var(--bg-panel); border-top: 1px solid var(--border); }
        .btn-row { display: flex; justify-content: center; gap: 20px; margin-top: 15px; }
        
        .c-btn {
            width: 55px; height: 55px; border-radius: 50%; border: none; cursor: pointer;
            display: flex; align-items: center; justify-content: center; font-size: 1.4rem; color: #fff;
            transition: 0.2s; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .c-btn:active { transform: scale(0.95); }
        
        .btn-play { background: var(--primary); color: #000; width: 65px; height: 65px; font-size: 1.8rem; }
        .btn-play:hover { box-shadow: 0 0 25px var(--primary); }
        
        .btn-step { background: var(--bg-core); border: 2px solid var(--text-dim); color: var(--text-main); }
        .btn-step:hover { border-color: var(--gold); color: var(--gold); box-shadow: 0 0 15px rgba(255, 215, 0, 0.2); }
        
        .btn-reset { width: 40px; height: 40px; background: transparent; border: 1px solid var(--border); color: var(--text-dim); font-size: 1rem; }
        .btn-reset:hover { color: #fff; border-color: #fff; }

        .slider-container { display: flex; justify-content: space-between; font-size: 0.8rem; color: var(--text-dim); }
        input[type=range] { width: 60%; accent-color: var(--primary); cursor: pointer; }

        /* ANIMATIONS */
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        @keyframes shine { 0% { left: -100%; } 100% { left: 100%; } }
        @keyframes spin-crown { 0% { transform: rotateY(0deg); } 100% { transform: rotateY(360deg); } }
        @keyframes popIn { from { transform: scale(0); } to { transform: scale(1); } }
        @keyframes slideIn { from { opacity: 0; transform: translateX(10px); } to { opacity: 1; transform: translateX(0); } }

    </style>
</head>
<body>

    <div id="splash-screen">
        <div class="royal-card" onclick="changeJoke()">
            <div class="crown">ğŸ‘‘</div>
            <div class="royal-title">×”×©×œ×™×˜ ×”×‘×œ×ª×™ ××¢×•×¨×¢×¨</div>
            <h2 class="royal-name">× ×•×¢× ×¨×¤×•×¤×•×¨×˜</h2>
            <div class="funny-subtitle" id="jokeText">×××™×™×Ÿ ××¢×¨×›×™× ×‘××‘×˜ ×‘×œ×‘×“...</div>
            <button class="start-btn-large" onclick="startApp()">×”×ª×—×œ ×œ×œ××•×“ ğŸš€</button>
        </div>
        <p style="margin-top:20px; color: #555; font-size: 0.8rem;">×œ×—×¥ ×¢×œ ×”×›×¨×˜×™×¡ ×œ×”×—×œ×¤×ª ×¢×•×‘×“×”</p>
    </div>

    <div id="app-interface">
        <header>
            <div class="app-logo">Algo<span>Lab</span> Pro</div>
            <div class="nav-pills">
                <button class="nav-btn active" onclick="app.load('Dijkstra')">Dijkstra</button>
                <button class="nav-btn" onclick="app.load('BFS')">BFS</button>
                <button class="nav-btn" onclick="app.load('DFS')">DFS</button>
                <button class="nav-btn" onclick="app.load('SCC')">SCC</button>
                <button class="nav-btn" onclick="app.load('DAG')">DAG</button>
                <button class="nav-btn" onclick="app.load('Bellman')">Bellman-Ford</button>
            </div>
        </header>

        <div class="main-grid">
            <div class="stage">
                <svg id="svgLayer">
                    <defs>
                        <marker id="arrow" markerWidth="10" markerHeight="7" refX="32" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#334155" />
                        </marker>
                        <marker id="arrow-active" markerWidth="10" markerHeight="7" refX="32" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#ffd700" />
                        </marker>
                    </defs>
                    <g id="g-edges"></g>
                    <g id="g-nodes"></g>
                </svg>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <h3><span id="dsTitle">××‘× ×” × ×ª×•× ×™×</span> <small style="opacity:0.5">LIVE</small></h3>
                    <div class="ds-items" id="dsContainer"></div>
                </div>

                <div class="log-container" id="logBox">
                    <div class="log-entry l-info">×‘×¨×•×š ×”×‘× ×œ××¢×‘×“×”. ×‘×—×¨ ××œ×’×•×¨×™×ª× ×•×”×ª×—×œ ×œ×¨×•×¥.</div>
                </div>

                <div class="controls">
                    <div class="slider-container">
                        <span>××”×™×¨×•×ª ×× ×™××¦×™×”</span>
                        <input type="range" id="speedRange" min="100" max="2000" value="1000" step="100" dir="ltr">
                    </div>
                    <div class="btn-row">
                        <button class="c-btn btn-reset" onclick="app.reset()" title="××™×¤×•×¡">â†º</button>
                        <button class="c-btn btn-play" id="playBtn" onclick="app.toggleAuto()" title="××•×˜×•××˜×™">â–¶</button>
                        <button class="c-btn btn-step" onclick="app.manualStep()" title="×¦×¢×“ ×™×“× ×™">âœ</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* --- JOKES & SPLASH LOGIC --- */
        const jokes = [
            "××—×©×‘ ××¡×œ×•×œ ×§×¦×¨ ×œ××§×¨×¨...",
            "×¤×ª×¨ ××ª P=NP ×‘×”×¤×¡×§×ª ×§×¤×”",
            "Dijkstra ×‘×™×§×© ××× ×• ×¢×–×¨×” ×‘×©×™×¢×•×¨×™ ×‘×™×ª",
            "×¨×¥ ×‘×¡×™×‘×•×›×™×•×ª O(1)",
            "×”××™×©, ×”××’×“×”, ×•×”×§×•×“×§×•×“",
            "×œ× ×¦×¨×™×š GPS, ×™×© ×œ×• BFS",
            "××›×™×¨ ××ª ×›×œ ×”××¢×’×œ×™× ×”×©×œ×™×œ×™×™× ×‘×©×›×•× ×”"
        ];

        function changeJoke() {
            const el = document.getElementById('jokeText');
            el.style.opacity = 0;
            setTimeout(() => {
                el.innerText = jokes[Math.floor(Math.random() * jokes.length)];
                el.style.opacity = 1;
            }, 200);
        }
        setInterval(changeJoke, 4000);

        function startApp() {
            const splash = document.getElementById('splash-screen');
            const app = document.getElementById('app-interface');
            
            splash.style.opacity = '0';
            splash.style.transform = 'scale(1.1)';
            
            setTimeout(() => {
                splash.style.display = 'none';
                app.style.display = 'grid';
                // Trigger reflow
                void app.offsetWidth;
                app.style.opacity = '1';
            }, 800);
        }

        /* --- APP LOGIC --- */
        const SCENARIOS = {
            GENERAL: {
                nodes: [0,1,2,3,4,5],
                edges: [
                    {u:0,v:1,w:5},{u:0,v:2,w:2},{u:1,v:2,w:6},{u:1,v:3,w:1},{u:1,v:4,w:10},
                    {u:2,v:3,w:9},{u:2,v:4,w:1},{u:3,v:4,w:7},{u:3,v:5,w:1},{u:4,v:5,w:5},{u:5,v:1,w:2}
                ],
                pos: {0:{x:100,y:300},1:{x:300,y:150},2:{x:300,y:450},3:{x:600,y:150},4:{x:600,y:450},5:{x:800,y:300}}
            },
            DAG: { // ××”×§×•×‘×¥ ×’×"×œ
                nodes: [0,1,2,3,4,5],
                edges: [
                    {u:0,v:1,w:2},{u:0,v:2,w:6},{u:1,v:2,w:7},{u:1,v:3,w:4},{u:1,v:4,w:2},
                    {u:2,v:3,w:-1},{u:2,v:4,w:1},{u:3,v:4,w:-2},{u:4,v:5,w:2}
                ],
                pos: {0:{x:80,y:300},1:{x:250,y:150},2:{x:250,y:450},3:{x:500,y:150},4:{x:500,y:450},5:{x:700,y:300}}
            },
            BELLMAN: { // ××§×•×‘×¥ ×‘×œ××Ÿ-×¤×•×¨×“
                nodes: [1,2,3,4],
                edges: [
                    {u:1,v:2,w:4},{u:1,v:3,w:2},{u:2,v:3,w:1},{u:3,v:2,w:1},{u:2,v:4,w:4},{u:3,v:4,w:2},{u:4,v:2,w:-2}
                ],
                pos: {1:{x:150,y:300},2:{x:450,y:150},3:{x:450,y:450},4:{x:750,y:300}}
            }
        };

        class App {
            constructor() {
                this.graph = SCENARIOS.GENERAL;
                this.algo = 'Dijkstra';
                this.gen = null;
                this.isPlaying = false;
                this.timer = null;
                
                this.els = {
                    edges: document.getElementById('g-edges'),
                    nodes: document.getElementById('g-nodes'),
                    log: document.getElementById('logBox'),
                    ds: document.getElementById('dsContainer'),
                    dsTitle: document.getElementById('dsTitle'),
                    playBtn: document.getElementById('playBtn'),
                    speed: document.getElementById('speedRange')
                };
                
                this.initGraph();
            }

            load(name) {
                this.algo = name;
                // UI Updates
                document.querySelectorAll('.nav-btn').forEach(b => {
                    b.classList.remove('active');
                    if(b.innerText === name) b.classList.add('active');
                });

                // Scenario Switch
                if(name === 'Bellman') this.graph = SCENARIOS.BELLMAN;
                else if(name === 'DAG') this.graph = SCENARIOS.DAG;
                else this.graph = SCENARIOS.GENERAL;

                this.reset();
            }

            /* --- VISUALIZATION --- */
            initGraph() {
                this.els.edges.innerHTML = '';
                this.els.nodes.innerHTML = '';

                // Edges
                this.graph.edges.forEach(e => {
                    const u = this.graph.pos[e.u], v = this.graph.pos[e.v];
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.innerHTML = `
                        <line x1="${u.x}" y1="${u.y}" x2="${v.x}" y2="${v.y}" class="edge" id="e-${e.u}-${e.v}" marker-end="url(#arrow)"></line>
                        <rect x="${(u.x+v.x)/2-10}" y="${(u.y+v.y)/2-10}" width="20" height="20" class="label-bg"></rect>
                        <text x="${(u.x+v.x)/2}" y="${(u.y+v.y)/2}" class="label-text">${e.w}</text>
                    `;
                    this.els.edges.appendChild(g);
                });

                // Nodes
                this.graph.nodes.forEach(n => {
                    const p = this.graph.pos[n];
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.setAttribute("class", "group");
                    g.setAttribute("id", `n-${n}`);
                    g.setAttribute("transform", `translate(${p.x},${p.y})`);
                    g.innerHTML = `
                        <circle class="node-circle"></circle>
                        <text class="node-text">${n}</text>
                        <text class="node-badge" id="b-${n}" y="-40"></text>
                    `;
                    this.els.nodes.appendChild(g);
                });
            }

            log(msg, type='l-info') {
                const d = document.createElement('div');
                d.className = `log-entry ${type}`;
                d.innerHTML = msg;
                this.els.log.appendChild(d);
                this.els.log.scrollTop = this.els.log.scrollHeight;
            }

            updateDS(items, active) {
                this.els.ds.innerHTML = '';
                items.forEach(x => {
                    const el = document.createElement('div');
                    el.className = `ds-item ${x == active ? 'active' : ''}`;
                    el.textContent = x;
                    this.els.ds.appendChild(el);
                });
            }

            hlNode(id, cls) {
                const el = document.getElementById(`n-${id}`);
                el.classList.remove('active', 'visited', 'finished');
                if(cls) el.classList.add(cls);
            }

            hlEdge(u, v, on) {
                const el = document.getElementById(`e-${u}-${v}`);
                if(!el) return;
                if(on) { el.classList.add('active'); el.setAttribute('marker-end', 'url(#arrow-active)'); }
                else { el.classList.remove('active'); el.setAttribute('marker-end', 'url(#arrow)'); }
            }

            badge(id, txt) {
                const el = document.getElementById(`b-${id}`);
                el.textContent = txt; el.style.opacity = 1;
            }

            /* --- CONTROLS --- */
            reset() {
                this.stopAuto();
                this.els.log.innerHTML = '';
                this.initGraph();
                this.updateDS([]);
                
                // Load Generator
                if(this.algo === 'Dijkstra') this.gen = this.runDijkstra();
                else if(this.algo === 'BFS') this.gen = this.runBFS();
                else if(this.algo === 'DFS') this.gen = this.runDFS();
                else if(this.algo === 'SCC') this.gen = this.runSCC();
                else if(this.algo === 'DAG') this.gen = this.runDAG();
                else if(this.algo === 'Bellman') this.gen = this.runBellman();
                
                this.log(`×”××œ×’×•×¨×™×ª× <b>${this.algo}</b> × ×˜×¢×Ÿ.`, 'l-info');
            }

            toggleAuto() {
                if(this.isPlaying) this.stopAuto(); else this.startAuto();
            }

            startAuto() {
                if(!this.gen) this.reset();
                this.isPlaying = true;
                this.els.playBtn.innerHTML = 'â¸';
                this.loop();
            }

            stopAuto() {
                this.isPlaying = false;
                clearTimeout(this.timer);
                this.els.playBtn.innerHTML = 'â–¶';
            }

            manualStep() {
                if(this.isPlaying) this.stopAuto();
                this.step();
            }

            step() {
                if(!this.gen) return false;
                const res = this.gen.next();
                if(res.done) {
                    this.stopAuto();
                    return false;
                }
                return true;
            }

            loop() {
                if(!this.isPlaying) return;
                if(this.step()) {
                    const delay = 2100 - this.els.speed.value;
                    this.timer = setTimeout(() => this.loop(), delay);
                }
            }

            /* --- ALGORITHMS --- */
            *runDijkstra() {
                const start = this.graph.nodes[0];
                this.els.dsTitle.innerText = "Priority Queue";
                const d={}, Q=new Set(this.graph.nodes);
                this.graph.nodes.forEach(n=>{d[n]=Infinity;}); d[start]=0;
                this.log(`×”×ª×—×œ×ª Dijkstra ××¦×•××ª ${start}`);

                while(Q.size){
                    let u=null, min=Infinity;
                    Q.forEach(n=>{if(d[n]<min){min=d[n];u=n;}});
                    if(u===null) break;
                    Q.delete(u);
                    
                    this.hlNode(u, 'active');
                    this.updateDS(Array.from(Q));
                    this.badge(u, `d:${d[u]}`);
                    this.log(`× ×‘×—×¨ <b>${u}</b> (min:${min})`, 'l-act');
                    yield;

                    const neighbors = this.graph.edges.filter(e=>e.u===u);
                    for(let e of neighbors){
                        if(!Q.has(e.v)) continue;
                        this.hlEdge(u,e.v,true);
                        const alt = d[u]+e.w;
                        this.log(`×‘×“×™×§×ª ×©×›×Ÿ ${e.v}: ${d[u]}+${e.w}=${alt}`, 'l-calc');
                        yield;
                        if(alt < d[e.v]){
                            d[e.v] = alt;
                            this.badge(e.v, `d:${alt}`);
                            this.log(`×¢×“×›×•×Ÿ ××¨×—×§ ×œ-${e.v} -> ${alt}`, 'l-success');
                        }
                        this.hlEdge(u,e.v,false);
                    }
                    this.hlNode(u, 'visited');
                }
                this.log("×¡×™×•×.", 'l-success');
            }

            *runBFS() {
                const start=this.graph.nodes[0];
                this.els.dsTitle.innerText = "Queue";
                const Q=[start], visited=new Set([start]);
                this.log(`×”×ª×—×œ×ª BFS ×-${start}`);
                while(Q.length){
                    this.updateDS([...Q]);
                    const u = Q.shift();
                    this.hlNode(u, 'active');
                    this.log(`×©×œ×™×¤×” ××”×ª×•×¨: <b>${u}</b>`, 'l-act');
                    yield;
                    const neighbors = this.graph.edges.filter(e=>e.u===u).map(e=>e.v);
                    for(let v of neighbors){
                        if(!visited.has(v)){
                            this.hlEdge(u,v,true);
                            visited.add(v); Q.push(v);
                            this.updateDS([...Q]);
                            this.log(`×’×™×œ×•×™ ×©×›×Ÿ ${v}`, 'l-calc');
                            yield;
                            this.hlEdge(u,v,false);
                        }
                    }
                    this.hlNode(u, 'visited');
                }
                this.log("×¡×™×•×.", 'l-success');
            }

            *runDFS() {
                const start=this.graph.nodes[0];
                this.els.dsTitle.innerText = "Stack";
                const stack=[start], visited=new Set();
                this.log(`×”×ª×—×œ×ª DFS ×-${start}`);
                while(stack.length){
                    const u = stack.pop();
                    if(!visited.has(u)){
                        visited.add(u);
                        this.hlNode(u, 'active');
                        this.updateDS([...stack, u]);
                        this.log(`×‘×™×§×•×¨ ×‘×¦×•××ª <b>${u}</b>`, 'l-act');
                        yield;
                        const neighbors = this.graph.edges.filter(e=>e.u===u).map(e=>e.v).reverse();
                        for(let v of neighbors){
                            if(!visited.has(v)) stack.push(v);
                        }
                        this.hlNode(u, 'visited');
                    }
                }
                this.log("×¡×™×•×.", 'l-success');
            }

            *runSCC() {
                this.els.dsTitle.innerText = "Recursion";
                let ids={}, low={}, stack=[], onStack={}, id=0, sccCount=0;
                const visited=new Set();
                const that = this;
                this.log("×”×ª×—×œ×ª SCC (Tarjan)");

                function* dfs(at){
                    stack.push(at); onStack[at]=true; visited.add(at);
                    ids[at]=low[at]=id++;
                    that.hlNode(at, 'active');
                    that.badge(at, `L:${low[at]}`);
                    that.updateDS(stack);
                    that.log(`Visit ${at} (id:${ids[at]})`, 'l-act');
                    yield;

                    const neighbors = that.graph.edges.filter(e=>e.u===at);
                    for(let e of neighbors){
                        if(!visited.has(e.v)){
                            that.hlEdge(at,e.v,true);
                            yield* dfs(e.v);
                            low[at]=Math.min(low[at], low[e.v]);
                            that.badge(at, `L:${low[at]}`);
                            that.log(`Backtrack ${at}: low updated`, 'l-calc');
                            that.hlNode(at, 'active');
                            yield;
                            that.hlEdge(at,e.v,false);
                        } else if(onStack[e.v]){
                            low[at]=Math.min(low[at], ids[e.v]);
                            that.badge(at, `L:${low[at]}`);
                            yield;
                        }
                    }
                    if(ids[at]===low[at]){
                        that.log(`SCC Root found at ${at}`, 'l-success');
                        while(stack.length){
                            const node = stack.pop();
                            onStack[node]=false;
                            document.getElementById(`n-${node}`).setAttribute('data-scc', sccCount%3);
                            that.updateDS(stack);
                            if(node===at) break;
                            yield;
                        }
                        sccCount++;
                    }
                }
                for(let n of this.graph.nodes) if(!visited.has(n)) yield* dfs(n);
                this.log(`× ××¦××• ${sccCount} ×¨×›×™×‘×™×.`, 'l-success');
            }

            *runDAG() {
                const start=this.graph.nodes[0];
                this.els.dsTitle.innerText = "Topo Sort";
                const inDegree={}; this.graph.nodes.forEach(n=>inDegree[n]=0);
                this.graph.edges.forEach(e=>inDegree[e.v]++);
                const q = this.graph.nodes.filter(n=>inDegree[n]===0);
                const topo=[];
                
                this.log("×©×œ×‘ 1: ××™×•×Ÿ ×˜×•×¤×•×œ×•×’×™");
                while(q.length){
                    const u = q.shift();
                    topo.push(u);
                    this.hlNode(u, 'finished');
                    this.updateDS(topo);
                    yield;
                    this.graph.edges.filter(e=>e.u===u).forEach(e=>{
                        inDegree[e.v]--;
                        if(inDegree[e.v]===0) q.push(e.v);
                    });
                }
                this.log("×©×œ×‘ 2: ×—×™×©×•×‘ ××¨×—×§×™×", 'l-act');
                this.graph.nodes.forEach(n=>this.hlNode(n, ''));
                const d={}; this.graph.nodes.forEach(n=>d[n]=Infinity); d[start]=0;
                this.badge(start, '0');

                for(let u of topo){
                    if(d[u]===Infinity) continue;
                    this.hlNode(u, 'active');
                    yield;
                    const neighbors = this.graph.edges.filter(e=>e.u===u);
                    for(let e of neighbors){
                        this.hlEdge(u,e.v,true);
                        if(d[u]+e.w < d[e.v]){
                            d[e.v] = d[u]+e.w;
                            this.badge(e.v, `d:${d[e.v]}`);
                            this.log(`Relax ${e.v} -> ${d[e.v]}`, 'l-success');
                        }
                        yield;
                        this.hlEdge(u,e.v,false);
                    }
                    this.hlNode(u, 'visited');
                }
                this.log("×¡×™×•×.", 'l-success');
            }

            *runBellman() {
                const start=this.graph.nodes[0];
                this.els.dsTitle.innerText = "Iteration";
                const d={}; this.graph.nodes.forEach(n=>{d[n]=Infinity;this.badge(n,'âˆ');});
                d[start]=0; this.badge(start, '0');
                this.log("×”×ª×—×œ×ª Bellman-Ford (|V|-1 ××™×˜×¨×¦×™×•×ª)");

                for(let i=1; i<this.graph.nodes.length; i++){
                    this.log(`--- ××™×˜×¨×¦×™×” ${i} ---`, 'l-act');
                    this.updateDS([`i=${i}`]);
                    let changed = false;
                    for(let e of this.graph.edges){
                        this.hlEdge(e.u, e.v, true);
                        this.hlNode(e.u, 'active');
                        if(d[e.u]!==Infinity && d[e.u]+e.w < d[e.v]){
                            d[e.v] = d[e.u]+e.w;
                            this.badge(e.v, `d:${d[e.v]}`);
                            this.log(`×©×™×¤×•×¨ ×§×©×ª (${e.u},${e.v}) -> ${d[e.v]}`, 'l-success');
                            changed=true;
                        }
                        yield;
                        this.hlEdge(e.u, e.v, false);
                        this.hlNode(e.u, '');
                    }
                    if(!changed){ this.log("××™×Ÿ ×©×™× ×•×™×™×, ×¢×¦×™×¨×” ××•×§×“××ª.", 'l-info'); break; }
                }
                // Check Cycle
                for(let e of this.graph.edges){
                    if(d[e.u]!==Infinity && d[e.u]+e.w < d[e.v]){
                        this.log("âš ï¸ ×–×•×”×” ××¢×’×œ ×©×œ×™×œ×™!", 'l-err');
                        return;
                    }
                }
                this.log("×¡×™×•× ×ª×§×™×Ÿ.", 'l-success');
            }
        }

        const app = new App();
    </script>
</body>
</html>
